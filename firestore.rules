
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    function isGroupMember(groupId) {
      return get(/databases/$(database)/documents/groups/$(groupId)).data.members.hasAny([request.auth.uid]);
    }

    match /groups/{groupId} {
      allow read: if request.auth != null;
      allow create: if request.auth.uid == request.resource.data.createdBy;

      allow update: if 
        // Allow any update by an existing member (for future features like changing group name)
        isGroupMember(groupId) || 

        // OR, allow a non-member to join, under strict conditions
        (
          !isGroupMember(groupId) &&
          // The request must be an update, not a create or delete
          request.resource.data.diff(resource.data) != null &&

          // Check that only 'members' and 'memberInfo' are being changed
          request.resource.data.diff(resource.data).affectedKeys().hasOnly(['members', 'memberInfo']) &&
          
          // Verify the 'members' array change: exactly one new member (themselves)
          request.resource.data.members == resource.data.members.concat([request.auth.uid]) &&

          // Verify the 'memberInfo' map change: exactly one new key (their own uid)
          // This robustly handles the case where 'memberInfo' might not exist on the old document
          request.resource.data.memberInfo.size() == resource.data.get('memberInfo', {}).size() + 1 &&
          request.resource.data.memberInfo[request.auth.uid] != null
        );

      match /fr_pool/{albumId} {
        allow read, write: if isGroupMember(groupId);
      }

      match /inter_pool/{albumId} {
        allow read, write: if isGroupMember(groupId);
      }
      
      match /rankings/{userId} {
        // Corrected the typo 'isGroup-Member' to 'isGroupMember'
        allow read: if isGroupMember(groupId);
        // Allow user to create their OWN ranking doc.
        allow create: if request.auth.uid == userId;
        // Allow update only if user is a member and it's their own doc.
        allow update: if request.auth.uid == userId && isGroupMember(groupId);
      }
    }
    
    // This rule allows the collectionGroup query for the Community View.
        match /{path=**}/rankings/{userId} {
                allow read: if get(/databases/$(database)/documents/groups/$(resource.data.userInfo.groupId)).data.members.hasAny([request.auth.uid]);
        }
  }
}